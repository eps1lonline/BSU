import numpy as np

def nonlin(x, deriv=False):
    if deriv:
        return x * (1 - x)  # Производная сигмоиды
    return 1 / (1 + np.exp(-x))  # Сигмоида

# Входные данные
X = np.array([[0.5, 1, 1],  # 50%, есть пистолет, 1 враг
              [0.9, 1, 2],  # 90%, есть пистолет, 2 врага
              [0.8, 0, 1],  # 80%, нет пистолета, 1 враг
              [0.3, 1, 1],  # 30%, есть пистолет, 1 враг
              [0.6, 1, 2],  # 60%, есть пистолет, 2 врага
              [0.4, 0, 1],  # 40%, нет пистолета, 1 враг
              [0.9, 1, 7],  # 90%, есть пистолет, 7 врагов
              [0.6, 1, 4],  # 60%, есть пистолет, 4 врага
              [0.1, 0, 1],  # 10%, нет пистолета, 1 враг
              [0.6, 1, 0],  # 60%, есть пистолет, 0 врагов
              [1.0, 0, 0]]) # 100%, нет пистолета, 0 врагов

# Выходные данные для К, И, А
y = np.array([[1, 0, 0, 0],  # Атаковать
              [1, 0, 0, 0],  # Атаковать
              [1, 0, 0, 0],  # Атаковать
              [0, 1, 0, 0],  # Прятаться
              [0, 1, 0, 0],  # Прятаться
              [0, 1, 0, 0],  # Прятаться
              [0, 0, 1, 0],  # Бежать
              [0, 0, 1, 0],  # Бежать
              [0, 0, 1, 0],  # Бежать
              [0, 0, 0, 1],  # Ничего
              [0, 0, 0, 1]]) # Ничего


np.random.seed(1)

# Инициализация весов
syn0 = 2 * np.random.random((3, 4)) - 1  # Входной слой (3 нейрона) к скрытому слою (4 нейрона)
syn1 = 2 * np.random.random((4, 4)) - 1  # Скрытый слой (4 нейрона) к выходному слою (4 нейрона)

# Обучение сети
for j in range(60000):
    # Прямое распространение
    l0 = X
    l1 = nonlin(np.dot(l0, syn0))  # Первый скрытый слой
    l2 = nonlin(np.dot(l1, syn1))   # Выходной слой

    # Вычисление ошибки
    l2_error = y - l2
    
    if (j % 10000) == 0:
        print("Error:" + str(np.mean(np.abs(l2_error))))
        
    # Обратное распространение
    l2_delta = l2_error * nonlin(l2, deriv=True)  # Ошибка на выходе
    l1_error = l2_delta.dot(syn1.T)  # Ошибка для первого скрытого слоя
    l1_delta = l1_error * nonlin(l1, deriv=True)  # Ошибка с учетом производной

    # Обновление весов
    syn1 += l1.T.dot(l2_delta)  # Обновление весов между скрытым и выходным слоями
    syn0 += l0.T.dot(l1_delta)  # Обновление весов между входным и скрытым слоями

# Вывод результатов с округлением
print("Выходные данные после тренировки:")
print(np.round(l2,3))


# Проверка нейросети
test_cases = np.array([[0.7, 1, 3],  # Пример 1: здоровье 70%, есть пистолет, 3 врага
                       [0.2, 0, 2],  # Пример 2: здоровье 20%, нет пистолета, 2 врага
                       [0.5, 1, 0],  # Пример 3: здоровье 50%, есть пистолет, 0 врагов
                       [0.9, 0, 5]]) # Пример 4: здоровье 90%, нет пистолета, 5 врагов

l1_test = nonlin(np.dot(test_cases, syn0))  # Первый скрытый слой
l2_test = nonlin(np.dot(l1_test, syn1))      # Выходной слой

# Вывод результатов для тестовых случаев
print("Результаты для тестовых случаев:")
for i, result in enumerate(np.round(l2_test, 3)):
    action = np.argmax(result)
    if action == 0:
        print(f"Тестовый случай {i+1}: Атаковать")
    elif action == 1:
        print(f"Тестовый случай {i+1}: Прятаться")
    elif action == 2:
        print(f"Тестовый случай {i+1}: Бежать")
    else:
        print(f"Тестовый случай {i+1}: Ничего не делать")